<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo de Tangram Interativo</title>
    <style>
        /* --- ESTRUTURA GERAL E LAYOUT --- */
        :root {
            /* Definimos L (o lado do quadrado) como 400px. Todas as peças são baseadas nisso. */
            --L: 400px;
            --cor-fundo: #f0f0f0;
            --cor-container: #ffffff;
            --cor-borda: #cccccc;
            --cor-sombra: rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--cor-fundo);
            margin: 0;
            padding: 20px;
            color: #333;
            user-select: none; /* Impede a seleção de texto ao arrastar */
        }

        h1, h2 {
            text-align: center;
            margin-bottom: 10px;
        }

        #game-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
        }

        .container {
            background-color: var(--cor-container);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px var(--cor-sombra);
            border: 1px solid var(--cor-borda);
        }

        #game-container {
            width: calc(var(--L) + 40px);
            height: calc(var(--L) + 40px);
            position: relative;
        }

        #gabarito {
            width: var(--L);
            height: var(--L);
            border: 3px dashed #a0a0a0;
            position: absolute;
            top: 20px;
            left: 20px;
            box-sizing: border-box;
            pointer-events: none; /* Não interfere com o clique do mouse */
        }
        
        #pieces-palette {
            position: relative;
            width: 280px; /* Largura fixa para a paleta */
            height: calc(var(--L) + 40px);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #win-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(34, 139, 34, 0.9);
            color: white;
            padding: 30px 50px;
            border-radius: 15px;
            font-size: 2em;
            text-align: center;
            z-index: 200;
            display: none; /* Começa escondido */
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        /* --- CONTROLES E INSTRUÇÕES --- */
        .controls {
            text-align: center;
            width: 280px;
        }
        .controls ul {
            list-style: none;
            padding: 0;
            text-align: left;
            margin: 15px auto;
            max-width: 220px;
        }
        .controls li { margin-bottom: 8px; }
        .controls button {
            padding: 12px 25px;
            font-size: 1em;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            margin: 5px;
        }
        #check-button { background-color: #007BFF; }
        #check-button:hover { background-color: #0056b3; }
        #reset-button { background-color: #dc3545; }
        #reset-button:hover { background-color: #c82333; }
        .controls button:active { transform: scale(0.95); }

        /* --- PEÇAS DO TANGRAM --- */
        .tangram-piece {
            position: absolute;
            cursor: grab;
            transition: transform 0.15s ease-out; /* Suaviza rotação/inversão */
            transform-origin: center center;
            box-sizing: border-box;
            border: 1px solid rgba(0, 0, 0, 0.3);
            /* Garante que o texto dentro não seja selecionável */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .tangram-piece.dragging {
            cursor: grabbing;
            z-index: 100;
            box-shadow: 0 10px 20px rgba(0,0,0,0.25);
        }
        
        /* Estilo para a peça selecionada para feedback visual */
        .tangram-piece.selected-piece {
            outline: 3px solid #007BFF;
            outline-offset: 3px;
        }

        /* 
         CÁLCULO DAS DIMENSÕES (Baseado em L = 400px)
         A geometria do Tangram dita as dimensões para o encaixe perfeito.
        */
        .triangle-big {
            width: calc(var(--L) / 1.41421356); /* L/sqrt(2) */
            height: calc(var(--L) / 1.41421356);
            clip-path: polygon(0 0, 100% 0, 0 100%);
        }
        .triangle-medium {
            width: calc(var(--L) / 2); /* L/2 */
            height: calc(var(--L) / 2);
            clip-path: polygon(0 0, 100% 0, 0 100%);
        }
        .triangle-small {
            width: calc(var(--L) / (2 * 1.41421356)); /* L/(2*sqrt(2)) */
            height: calc(var(--L) / (2 * 1.41421356));
            clip-path: polygon(0 0, 100% 0, 0 100%);
        }
        .square {
            width: calc(var(--L) / (2 * 1.41421356)); /* L/(2*sqrt(2)) */
            height: calc(var(--L) / (2 * 1.41421356));
        }
        
        /* CORREÇÃO PARA O PARALELOGRAMO: usar calc() e medidas fixas */
        .parallelogram {
            width: calc(var(--L) / 2); 
            height: calc(var(--L) / 4);
            clip-path: polygon(25% 0%, 100% 0%, 75% 100%, 0% 100%);
        }

        /* Cores das Peças */
        #tb1 { background-color: #FFC107; } /* Amarelo (Big Triangle 1) */
        #tb2 { background-color: #03A9F4; } /* Azul Claro (Big Triangle 2) */
        #tm1 { background-color: #F44336; } /* Vermelho (Medium Triangle 1) */
        #ts1 { background-color: #9C27B0; } /* Roxo (Small Triangle 1) */
        #ts2 { background-color: #FF5722; } /* Laranja Escuro (Small Triangle 2) */
        #sq1 { background-color: #4CAF50; } /* Verde (Square 1) */
        #pr1 { background-color: #E91E63; } /* Rosa (Parallelogram 1) */
    </style>
</head>
<body>

    <h1>Tangram Interativo</h1>

    <div id="game-area">
        <div id="pieces-palette" class="container">
            <h2>Peças</h2>
            <!-- Peças são adicionadas aqui via JavaScript -->
        </div>

        <div id="game-container" class="container">
            <h2>Monte o Quadrado Aqui</h2>
            <div id="gabarito"></div>
            <div id="win-message">Parabéns!<br>Você conseguiu!</div>
            <!-- Peças arrastadas vêm para cá -->
        </div>
        
        <div class="controls container">
            <h2>Controles</h2>
            <ul>
                <li><strong>Arrastar:</strong> Botão esquerdo do mouse.</li>
                <li><strong>Girar 45°:</strong> Tecla 'R' (na peça selecionada).</li>
                <li><strong>Inverter:</strong> Tecla 'F' (no paralelogramo selecionado).</li>
            </ul>
            <button id="check-button">Verificar Encaixe</button>
            <button id="reset-button">Reiniciar Jogo</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const gameContainer = document.getElementById('game-container');
            const piecesPalette = document.getElementById('pieces-palette');
            const resetButton = document.getElementById('reset-button');
            const checkButton = document.getElementById('check-button');
            const winMessage = document.getElementById('win-message');

            const L = 400;
            const L_2 = L / 2;
            const L_4 = L / 4;
            const SQRT2 = Math.SQRT2; // 1.41421356...
            
            // --- CONFIGURAÇÃO DA SOLUÇÃO DO JOGO ---
            const piecesConfig = {
                // As coordenadas (x, y) são o canto superior esquerdo da caixa delimitadora
                // da peça *antes* de qualquer transformação, em relação ao canto do GABARITO (0,0).
                'tb1': { class: 'triangle-big', initial: { top: '50px', left: '0px' }, solution: { x: 0, y: L_2, r: 90, f: false } },
                'tb2': { class: 'triangle-big', initial: { top: '50px', left: '50px' }, solution: { x: 0, y: 0, r: 0, f: false } },
                'tm1': { class: 'triangle-medium', initial: { top: '200px', left: '40px' }, solution: { x: L_2, y: 0, r: 270, f: false } },
                'ts1': { class: 'triangle-small', initial: { top: '350px', left: '10px' }, solution: { x: L_2 + L_4, y: L_2 + L_4, r: 180, f: false } },
                'ts2': { class: 'triangle-small', initial: { top: '350px', left: '130px' }, solution: { x: L_2, y: L_2, r: 270, f: false } },
                
                // ### INÍCIO DA ALTERAÇÃO 1 ###
                // A posição do quadrado foi corrigida. Para o centro dele estar em (L/2, L/2),
                // seu canto superior esquerdo (x,y) deve ser (L/2 - largura/2, L/2 - altura/2).
                'sq1': { class: 'square', initial: { top: '220px', left: '130px' }, solution: { x: L_2 - L/(2*SQRT2)/2, y: L_2 - L/(2*SQRT2)/2, r: 45, f: false } },
                // ### FIM DA ALTERAÇÃO 1 ###

                'pr1': { class: 'parallelogram', initial: { top: '150px', left: '0px' }, solution: { x: L_4, y: L_2, r: 90, f: true } }
            };
            
            let draggedPiece = null;
            let selectedPiece = null;
            let offsetX, offsetY;
            const pieceStates = new Map();

            // --- FUNÇÕES PRINCIPAIS DO JOGO ---

            function initializeGame() {
                piecesPalette.innerHTML = '<h2>Peças</h2>';
                gameContainer.querySelectorAll('.tangram-piece').forEach(p => p.remove());
                winMessage.style.display = 'none';

                if(selectedPiece) selectedPiece.classList.remove('selected-piece');
                selectedPiece = null;
                draggedPiece = null;

                for (const id in piecesConfig) {
                    const config = piecesConfig[id];
                    const piece = document.createElement('div');
                    piece.id = id;
                    piece.className = `tangram-piece ${config.class}`;
                    
                    piece.style.top = config.initial.top;
                    piece.style.left = config.initial.left;
                    pieceStates.set(piece, { rotation: 0, flipped: false, parent: 'palette' });
                    applyTransform(piece);

                    piecesPalette.appendChild(piece);
                    piece.addEventListener('mousedown', onPieceClick);
                }
            }

            function applyTransform(piece) {
                const state = pieceStates.get(piece);
                let transform = `rotate(${state.rotation}deg)`;
                if (state.flipped) {
                    transform += ' scaleX(-1)';
                }
                piece.style.transform = transform;
            }

            // --- LÓGICA DE SELEÇÃO, ARRASTO E SOLTURA ---

            function onPieceClick(e) {
                const currentPiece = e.target.closest('.tangram-piece');
                if (!currentPiece) return;

                if (selectedPiece && selectedPiece !== currentPiece) {
                    selectedPiece.classList.remove('selected-piece');
                }
                selectedPiece = currentPiece;
                selectedPiece.classList.add('selected-piece');

                if (e.button !== 0) return;

                draggedPiece = selectedPiece;
                draggedPiece.classList.add('dragging');
                
                const rect = draggedPiece.getBoundingClientRect();
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;

                if (pieceStates.get(draggedPiece).parent === 'palette') {
                    const paletteRect = piecesPalette.getBoundingClientRect();
                    const gameRect = gameContainer.getBoundingClientRect();
                    
                    const currentLeftInPalette = parseFloat(draggedPiece.style.left) || 0;
                    const currentTopInPalette = parseFloat(draggedPiece.style.top) || 0;

                    draggedPiece.style.left = `${(paletteRect.left + currentLeftInPalette) - gameRect.left}px`;
                    draggedPiece.style.top = `${(paletteRect.top + currentTopInPalette) - gameRect.top}px`;
                    
                    gameContainer.appendChild(draggedPiece);
                    pieceStates.get(draggedPiece).parent = 'game';
                }

                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', stopDrag);
            }

            function drag(e) {
                if (!draggedPiece) return;
                const gameRect = gameContainer.getBoundingClientRect();
                draggedPiece.style.left = `${e.clientX - gameRect.left - offsetX}px`;
                draggedPiece.style.top = `${e.clientY - gameRect.top - offsetY}px`;
            }

            function stopDrag() {
                if (!draggedPiece) return;
                draggedPiece.classList.remove('dragging');
                draggedPiece = null;
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('mouseup', stopDrag);
            }

            // --- LÓGICA DE ROTAÇÃO E INVERSÃO PELO TECLADO ---
            document.addEventListener('keydown', (e) => {
                if (!selectedPiece) return;

                const state = pieceStates.get(selectedPiece);

                if (e.key === 'r' || e.key === 'R') {
                    e.preventDefault();
                    state.rotation = (state.rotation + 45) % 360;
                    applyTransform(selectedPiece);
                } 
                else if ((e.key === 'f' || e.key === 'F') && selectedPiece.id === 'pr1') {
                    e.preventDefault();
                    state.flipped = !state.flipped;
                    applyTransform(selectedPiece);
                }
            });

            document.addEventListener('mousedown', (e) => {
                if (!e.target.closest('.tangram-piece') && selectedPiece) {
                    selectedPiece.classList.remove('selected-piece');
                    selectedPiece = null;
                }
            });

            // ### INÍCIO DA ALTERAÇÃO 2 ###
            // --- FUNÇÃO DE VERIFICAÇÃO DE VITÓRIA CORRIGIDA ---
            function checkWinCondition() {
                const tolerancePos = 15; // Tolerância em pixels para a posição do centro
                const toleranceRot = 10; // Tolerância em graus para a rotação
                
                const piecesInGameArea = Array.from(gameContainer.querySelectorAll('.tangram-piece'));
                if (piecesInGameArea.length !== 7) {
                     alert('Por favor, mova todas as 7 peças para a área de montagem antes de verificar.');
                     return;
                }

                let allCorrect = true;
                const gabaritoRect = document.getElementById('gabarito').getBoundingClientRect();
                const gameRect = gameContainer.getBoundingClientRect();
                
                const gabaritoOffsetX = gabaritoRect.left - gameRect.left;
                const gabaritoOffsetY = gabaritoRect.top - gameRect.top;

                for (const piece of piecesInGameArea) {
                    const state = pieceStates.get(piece);
                    const solution = piecesConfig[piece.id].solution;
                    
                    // 1. Calcular o centro da peça ATUAL na tela.
                    //    'style.left' e 'offsetWidth' referem-se à caixa original, não transformada,
                    //    o que é exatamente o que precisamos para ter um ponto de referência estável.
                    const currentPieceCenterX = (parseFloat(piece.style.left) || 0) + piece.offsetWidth / 2;
                    const currentPieceCenterY = (parseFloat(piece.style.top) || 0) + piece.offsetHeight / 2;

                    // Ajusta o centro para ser relativo ao gabarito, não ao game-container
                    const currentCenterX_RelativeToGabarito = currentPieceCenterX - gabaritoOffsetX;
                    const currentCenterY_RelativeToGabarito = currentPieceCenterY - gabaritoOffsetY;

                    // 2. Calcular o centro ESPERADO da peça na solução.
                    //    Como solution.x/y é o canto superior esquerdo, somamos metade da
                    //    largura/altura originais para encontrar o centro esperado.
                    //    `piece.offsetWidth/Height` nos dá as dimensões corretas da caixa original.
                    const solutionCenterX = solution.x + piece.offsetWidth / 2;
                    const solutionCenterY = solution.y + piece.offsetHeight / 2;

                    // 3. Comparar os centros (posição)
                    const posCorrect = Math.abs(currentCenterX_RelativeToGabarito - solutionCenterX) < tolerancePos && 
                                       Math.abs(currentCenterY_RelativeToGabarito - solutionCenterY) < tolerancePos;
                    
                    // 4. Comparar a rotação
                    const normalizedCurrentRot = (state.rotation % 360 + 360) % 360;
                    const normalizedSolutionRot = (solution.r % 360 + 360) % 360;
                    const rotDiff = Math.abs(normalizedCurrentRot - normalizedSolutionRot);
                    const rotCorrect = rotDiff < toleranceRot || (360 - rotDiff) < toleranceRot;

                    // 5. Comparar o estado de inversão
                    const flipCorrect = state.flipped === solution.f;

                    // Se qualquer verificação falhar, a peça está incorreta.
                    if (!posCorrect || !rotCorrect || !flipCorrect) {
                        allCorrect = false;
                        console.log(`--- Peça ${piece.id} Incorreta ---`);
                        console.log(`Centro Esperado (rel. gabarito): (${solutionCenterX.toFixed(1)}, ${solutionCenterY.toFixed(1)})`);
                        console.log(`Centro Atual (rel. gabarito): (${currentCenterX_RelativeToGabarito.toFixed(1)}, ${currentCenterY_RelativeToGabarito.toFixed(1)}) -> Pos OK: ${posCorrect}`);
                        console.log(`Rotação Esperada: ${solution.r}°, Atual: ${state.rotation}° -> Rot OK: ${rotCorrect}`);
                        console.log(`Inversão Esperada: ${solution.f}, Atual: ${state.flipped} -> Flip OK: ${flipCorrect}`);
                        // Não usamos 'break' para que todas as peças incorretas sejam logadas no console, ajudando a depurar.
                    }
                }

                if (allCorrect) {
                    winMessage.style.display = 'block';
                } else {
                    alert('Ainda não está correto. Continue tentando! (Verifique o console do navegador para dicas detalhadas)');
                }
            }
            // ### FIM DA ALTERAÇÃO 2 ###

            // --- INICIALIZAÇÃO E LISTENERS GERAIS ---
            resetButton.addEventListener('click', initializeGame);
            checkButton.addEventListener('click', checkWinCondition);
            
            initializeGame();
        });
    </script>
</body>
</html>
