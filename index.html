<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo de Tangram Interativo</title>
    <style>
        /* --- ESTRUTURA GERAL E LAYOUT --- */
        :root {
            --L: 400px;
            --cor-fundo: #f0f0f0;
            --cor-container: #ffffff;
            --cor-borda: #cccccc;
            --cor-sombra: rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--cor-fundo);
            margin: 0;
            padding: 20px;
            color: #333;
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            user-select: none; /* Padrão */
        }

        h1, h2 {
            text-align: center;
            margin-bottom: 10px;
        }

        #game-area {
            display: flex;
            flex-wrap: nowrap; /* Alterado para não quebrar linha por padrão */
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            width: 100%;
        }

        .container {
            background-color: var(--cor-container);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px var(--cor-sombra);
            border: 1px solid var(--cor-borda);
            flex-shrink: 0; /* Impede que os containers encolham */
        }

        #game-container {
            width: calc(var(--L) + 40px);
            height: calc(var(--L) + 40px);
            position: relative;
        }

        #gabarito {
            width: var(--L);
            height: var(--L);
            border: 3px dashed #a0a0a0;
            position: absolute;
            top: 20px;
            left: 20px;
            box-sizing: border-box;
            pointer-events: none;
        }
        
        #pieces-palette {
            position: relative;
            width: 280px;
            height: calc(var(--L) + 40px);
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #win-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(34, 139, 34, 0.9);
            color: white;
            padding: 30px 50px;
            border-radius: 15px;
            font-size: 2em;
            text-align: center;
            z-index: 200;
            display: none;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        /* --- CONTROLES E INSTRUÇÕES --- */
        .controls {
            text-align: center;
            width: 280px;
        }
        .controls ul {
            list-style: none;
            padding: 0;
            text-align: left;
            margin: 15px auto;
            max-width: 220px;
        }
        .controls li { margin-bottom: 8px; }
        .controls button {
            padding: 12px 20px;
            font-size: 1em;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            margin: 5px;
            width: calc(100% - 10px); /* Ocupa a largura total */
            box-sizing: border-box;
        }
        
        #check-button { background-color: #007BFF; }
        #check-button:hover { background-color: #0056b3; }
        #reset-button { background-color: #dc3545; }
        #reset-button:hover { background-color: #c82333; }
        #rotate-button, #flip-button { background-color: #6c757d; } /* Cinza para botões de ação */
        #rotate-button:hover, #flip-button:hover { background-color: #5a6268; }

        .controls button:active { transform: scale(0.98); }
        .controls button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            color: #888888;
        }
        .controls button:disabled:hover { background-color: #cccccc; }


        /* --- PEÇAS DO TANGRAM --- */
        .tangram-piece {
            position: absolute;
            cursor: grab;
            transition: transform 0.15s ease-out, box-shadow 0.2s, outline 0.2s;
            transform-origin: center center;
            box-sizing: border-box;
            border: 1px solid rgba(0, 0, 0, 0.3);
        }

        .tangram-piece.dragging {
            cursor: grabbing;
            z-index: 100;
            box-shadow: 0 10px 20px rgba(0,0,0,0.25);
        }
        
        .tangram-piece.selected-piece {
            outline: 3px solid #007BFF;
            outline-offset: 3px;
        }

        .triangle-big { width: calc(var(--L) / 1.41421); height: calc(var(--L) / 1.41421); clip-path: polygon(0 0, 100% 0, 0 100%); }
        .triangle-medium { width: calc(var(--L) / 2); height: calc(var(--L) / 2); clip-path: polygon(0 0, 100% 0, 0 100%); }
        .triangle-small { width: calc(var(--L) / (2 * 1.41421)); height: calc(var(--L) / (2 * 1.41421)); clip-path: polygon(0 0, 100% 0, 0 100%); }
        .square { width: calc(var(--L) / (2 * 1.41421)); height: calc(var(--L) / (2 * 1.41421)); }
        .parallelogram { width: calc(var(--L) * 0.75); height: calc(var(--L) / 4); clip-path: polygon(33.33% 0%, 100% 0%, 66.67% 100%, 0% 100%); }

        /* Cores */
        #tb1 { background-color: #FFC107; } #tb2 { background-color: #03A9F4; } #tm1 { background-color: #F44336; }
        #ts1 { background-color: #9C27B0; } #ts2 { background-color: #FF5722; } #sq1 { background-color: #4CAF50; }
        #pr1 { background-color: #E91E63; }

        /* --- LAYOUT RESPONSIVO PARA DISPOSITIVOS MÓVEIS --- */
        @media (max-width: 1024px) {
            #game-area {
                flex-direction: column;
                align-items: center;
                gap: 20px;
            }
            .container {
                width: 95%;
                max-width: 440px; /* Garante que não fique largo demais em tablets */
                height: auto; /* Altura automática */
            }
            #pieces-palette {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                gap: 10px;
                padding-top: 50px; /* Espaço para o H2 */
            }
             #pieces-palette > h2 {
                position: absolute;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
             }
            .tangram-piece {
                position: relative; /* Peças na paleta agora fluem normalmente */
                top: auto !important;
                left: auto !important;
            }
        }
    </style>
</head>
<body>

    <h1>Tangram Interativo</h1>

    <div id="game-area">
        <div id="pieces-palette" class="container">
            <h2>Peças</h2>
            <!-- Peças são adicionadas aqui via JavaScript -->
        </div>

        <div id="game-container" class="container">
            <h2>Monte o Quadrado Aqui</h2>
            <div id="gabarito"></div>
            <div id="win-message">Parabéns!<br>Você conseguiu!</div>
        </div>
        
        <div class="controls container">
            <h2>Controles</h2>
            <ul id="keyboard-instructions">
                <li><strong>Arrastar:</strong> Clique/Toque e segure.</li>
                <li><strong>Girar 45°:</strong> Tecla 'R'.</li>
                <li><strong>Inverter:</strong> Tecla 'F' (paralelogramo).</li>
            </ul>
            <!-- Botões para mobile -->
            <button id="rotate-button" disabled>Girar Peça</button>
            <button id="flip-button" disabled>Inverter Peça</button>
            <hr style="margin: 20px 0; border: 1px solid #eee;">
            <button id="check-button">Verificar Encaixe</button>
            <button id="reset-button">Reiniciar Jogo</button>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const gameContainer = document.getElementById('game-container');
        const piecesPalette = document.getElementById('pieces-palette');
        const resetButton = document.getElementById('reset-button');
        const checkButton = document.getElementById('check-button');
        const winMessage = document.getElementById('win-message');
        const rotateButton = document.getElementById('rotate-button');
        const flipButton = document.getElementById('flip-button');

        const L = 400; 
        const TOLERANCE_POS = 15; // Aumentar tolerância para facilitar no mobile
        const TOLERANCE_ROT = 10;
        
        const piecesConfig = {
            'tb1': { class: 'triangle-big', solution: { x: 0, y: L/2, r: 90, f: false } },
            'tb2': { class: 'triangle-big', solution: { x: 0, y: 0, r: 0, f: false } },
            'tm1': { class: 'triangle-medium', solution: { x: L/2, y: 0, r: 270, f: false } },
            'ts1': { class: 'triangle-small', solution: { x: L - L/4, y: L - L/4, r: 180, f: false } },
            'ts2': { class: 'triangle-small', solution: { x: L/2, y: L/2, r: 270, f: false } },
            'sq1': { class: 'square', solution: { x: L/4, y: L/4, r: 45, f: false } },
            'pr1': { class: 'parallelogram', solution: { x: L/4, y: 0, r: 0, f: true } }
        };
        
        let draggedPiece = null;
        let selectedPiece = null;
        let offsetX, offsetY;
        const pieceStates = new Map();

        function initializeGame() {
            piecesPalette.innerHTML = '<h2>Peças</h2>';
            gameContainer.querySelectorAll('.tangram-piece').forEach(p => p.remove());
            winMessage.style.display = 'none';

            if(selectedPiece) selectedPiece.classList.remove('selected-piece');
            selectedPiece = null;
            draggedPiece = null;

            for (const id in piecesConfig) {
                const config = piecesConfig[id];
                const piece = document.createElement('div');
                piece.id = id;
                piece.className = `tangram-piece ${config.class}`;
                
                pieceStates.set(piece, { rotation: 0, flipped: false, parent: 'palette' });
                applyTransform(piece);

                piecesPalette.appendChild(piece);
                
                // Adiciona listeners para mouse e toque
                piece.addEventListener('mousedown', startDrag);
                piece.addEventListener('touchstart', startDrag, { passive: false });
            }
            updateControlButtonsState();
        }

        function applyTransform(piece) {
            const state = pieceStates.get(piece);
            let transform = `rotate(${state.rotation}deg)`;
            if (state.flipped) {
                transform += ' scaleX(-1)';
            }
            piece.style.transform = transform;
        }

        function updateControlButtonsState() {
            if (!selectedPiece) {
                rotateButton.disabled = true;
                flipButton.disabled = true;
            } else {
                rotateButton.disabled = false;
                flipButton.disabled = selectedPiece.id !== 'pr1';
            }
        }
        
        function selectPiece(piece) {
            if (selectedPiece && selectedPiece !== piece) {
                selectedPiece.classList.remove('selected-piece');
            }
            selectedPiece = piece;
            if (selectedPiece) {
                selectedPiece.classList.add('selected-piece');
            }
            updateControlButtonsState();
        }

        function startDrag(e) {
            const currentPiece = e.target.closest('.tangram-piece');
            if (!currentPiece) return;

            selectPiece(currentPiece);
            
            // Para eventos de mouse, só arrastar com botão esquerdo
            if (e.type === 'mousedown' && e.button !== 0) return;

            e.preventDefault(); // Previne scroll no mobile

            draggedPiece = currentPiece;
            draggedPiece.classList.add('dragging');
            
            const rect = draggedPiece.getBoundingClientRect();
            const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
            const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
            
            offsetX = clientX - rect.left;
            offsetY = clientY - rect.top;

            if (pieceStates.get(draggedPiece).parent === 'palette') {
                const paletteRect = piecesPalette.getBoundingClientRect();
                
                // Garante que a peça é absoluta para cálculo de posição
                draggedPiece.style.position = 'absolute'; 

                // Converte a posição relativa da paleta para uma posição absoluta na página e depois para o game container
                const gameRect = gameContainer.getBoundingClientRect();
                draggedPiece.style.left = `${rect.left - gameRect.left}px`;
                draggedPiece.style.top = `${rect.top - gameRect.top}px`;
                
                gameContainer.appendChild(draggedPiece);
                pieceStates.get(draggedPiece).parent = 'game';
            }

            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('touchend', stopDrag);
        }

        function drag(e) {
            if (!draggedPiece) return;
            e.preventDefault(); // Previne scroll no mobile
            
            const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
            const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;

            const gameRect = gameContainer.getBoundingClientRect();
            draggedPiece.style.left = `${clientX - gameRect.left - offsetX}px`;
            draggedPiece.style.top = `${clientY - gameRect.top - offsetY}px`;
        }

        function stopDrag() {
            if (!draggedPiece) return;
            draggedPiece.classList.remove('dragging');
            draggedPiece = null;
            
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('touchmove', drag);
            document.removeEventListener('touchend', stopDrag);
        }
        
        function rotateSelectedPiece() {
            if (!selectedPiece) return;
            const state = pieceStates.get(selectedPiece);
            state.rotation = (state.rotation + 45) % 360;
            applyTransform(selectedPiece);
        }

        function flipSelectedPiece() {
            if (!selectedPiece || selectedPiece.id !== 'pr1') return;
            const state = pieceStates.get(selectedPiece);
            state.flipped = !state.flipped;
            applyTransform(selectedPiece);
        }

        document.addEventListener('keydown', (e) => {
            if (!selectedPiece) return;
            if (e.key === 'r' || e.key === 'R') {
                e.preventDefault();
                rotateSelectedPiece();
            } else if (e.key === 'f' || e.key === 'F') {
                e.preventDefault();
                flipSelectedPiece();
            }
        });

        document.addEventListener('mousedown', (e) => {
            // Desseleciona se clicar fora de uma peça
            if (!e.target.closest('.tangram-piece') && selectedPiece) {
                selectedPiece.classList.remove('selected-piece');
                selectedPiece = null;
                updateControlButtonsState();
            }
        });

        function checkWinCondition() {
            const piecesInGameArea = Array.from(gameContainer.querySelectorAll('.tangram-piece'));
            if (piecesInGameArea.length !== 7) {
                 alert('Por favor, mova todas as 7 peças para a área de montagem antes de verificar.');
                 return;
            }

            let allCorrect = true;
            const gabaritoRect = document.getElementById('gabarito').getBoundingClientRect();

            for (const piece of piecesInGameArea) {
                const state = pieceStates.get(piece);
                const solution = piecesConfig[piece.id].solution;
                const rect = piece.getBoundingClientRect();
                
                // Posição do centro da peça em relação ao gabarito
                const pieceCenterX = (rect.left + rect.width / 2) - gabaritoRect.left;
                const pieceCenterY = (rect.top + rect.height / 2) - gabaritoRect.top;
                
                // Posição do centro da peça na solução
                const solutionPiece = document.createElement('div');
                solutionPiece.className = piece.className;
                const solutionRect = solutionPiece.getBoundingClientRect();
                const solutionCenterX = solution.x + solutionRect.width / 2;
                const solutionCenterY = solution.y + solutionRect.height / 2;

                const posCorrect = Math.abs(pieceCenterX - solutionCenterX) < TOLERANCE_POS && 
                                   Math.abs(pieceCenterY - solutionCenterY) < TOLERANCE_POS;
                
                const normalizedCurrentRot = (state.rotation % 360 + 360) % 360;
                const normalizedSolutionRot = (solution.r % 360 + 360) % 360;
                const rotDiff = Math.abs(normalizedCurrentRot - normalizedSolutionRot);
                const rotCorrect = rotDiff < TOLERANCE_ROT || (360 - rotDiff) < TOLERANCE_ROT;

                const flipCorrect = state.flipped === solution.f;

                if (!posCorrect || !rotCorrect || !flipCorrect) {
                    allCorrect = false;
                    console.log(`--- Peça ${piece.id} Incorreta ---`);
                    console.log(`Posição (Centro): Esperado (${solutionCenterX.toFixed(1)}, ${solutionCenterY.toFixed(1)}), Atual (${pieceCenterX.toFixed(1)}, ${pieceCenterY.toFixed(1)})`);
                    console.log(`Rotação: Esperado ${solution.r}, Atual ${state.rotation}`);
                    console.log(`Inversão: Esperado ${solution.f}, Atual ${state.flipped}`);
                    break;
                }
            }

            if (allCorrect) {
                winMessage.style.display = 'block';
            } else {
                alert('Ainda não está correto. Continue tentando! (Verifique o console do navegador para dicas detalhadas)');
            }
        }

        // --- INICIALIZAÇÃO E LISTENERS DOS BOTÕES ---
        resetButton.addEventListener('click', initializeGame);
        checkButton.addEventListener('click', checkWinCondition);
        rotateButton.addEventListener('click', rotateSelectedPiece);
        flipButton.addEventListener('click', flipSelectedPiece);
        
        initializeGame();
    });
    </script>
</body>
</html>
