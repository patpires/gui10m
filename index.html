<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo de Tangram Interativo</title>
    <style>
        /* --- ESTRUTURA GERAL E LAYOUT --- */
        :root {
            /* Definimos L (o lado do quadrado) como 400px. Todas as peças são baseadas nisso. */
            --L: 400px;
            --cor-fundo: #f0f0f0;
            --cor-container: #ffffff;
            --cor-borda: #cccccc;
            --cor-sombra: rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--cor-fundo);
            margin: 0;
            padding: 20px;
            color: #333;
            user-select: none; /* Impede a seleção de texto ao arrastar */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            touch-action: manipulation; /* Permite gestos padrão do navegador, mas peças terão touch-action: none */
        }

        h1, h2 {
            text-align: center;
            margin-bottom: 10px;
        }

        #game-area {
            display: flex;
            flex-wrap: wrap; /* Permite que os elementos quebrem a linha em telas menores */
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            width: 100%; /* Ocupa a largura total para permitir o flex-wrap */
            max-width: 1200px; /* Limita a largura total do jogo */
        }

        .container {
            background-color: var(--cor-container);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px var(--cor-sombra);
            border: 1px solid var(--cor-borda);
        }

        #game-container {
            width: calc(var(--L) + 40px); /* L + padding */
            height: calc(var(--L) + 40px); /* L + padding */
            position: relative;
            overflow: hidden; /* Garante que as peças não saiam do container */
        }

        #gabarito {
            width: var(--L);
            height: var(--L);
            border: 3px dashed #a0a0a0;
            position: absolute;
            top: 20px;
            left: 20px;
            box-sizing: border-box;
            pointer-events: none; /* Não interfere com o clique do mouse */
        }
        
        #pieces-palette {
            position: relative;
            width: 280px; /* Largura fixa para a paleta no desktop */
            height: calc(var(--L) + 40px); /* Altura igual ao game-container */
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-y: auto; /* Para rolagem se houver muitas peças */
        }
        
        #win-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(34, 139, 34, 0.9);
            color: white;
            padding: 30px 50px;
            border-radius: 15px;
            font-size: 2em;
            text-align: center;
            z-index: 200;
            display: none; /* Começa escondido */
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        /* --- CONTROLES E INSTRUÇÕES --- */
        .controls {
            text-align: center;
            width: 280px; /* Largura fixa para controles no desktop */
        }
        .controls ul {
            list-style: none;
            padding: 0;
            text-align: left;
            margin: 15px auto;
            max-width: 220px;
        }
        .controls li { margin-bottom: 8px; }
        .controls button {
            padding: 12px 25px;
            font-size: 1em;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            margin: 5px;
        }
        #check-button { background-color: #007BFF; }
        #check-button:hover { background-color: #0056b3; }
        #reset-button { background-color: #dc3545; }
        #reset-button:hover { background-color: #c82333; }
        .controls button:active { transform: scale(0.95); }

        /* Botões R/F para Mobile */
        #mobile-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 150;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        #mobile-controls.active {
            opacity: 1;
            visibility: visible;
        }
        #mobile-controls button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            font-size: 1.8em;
            font-weight: bold;
            color: white;
            border: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s, box-shadow 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #mobile-controls button:hover:not(:disabled) {
            box-shadow: 0 6px 15px rgba(0,0,0,0.3);
        }
        #mobile-controls button:active:not(:disabled) {
            transform: scale(0.95);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #mobile-controls button:disabled {
            background-color: #cccccc !important;
            cursor: not-allowed;
            box-shadow: none;
            opacity: 0.7;
        }
        #rotate-button { background-color: #007BFF; } /* Azul */
        #flip-button { background-color: #FFC107; } /* Amarelo */


        /* --- PEÇAS DO TANGRAM --- */
        .tangram-piece {
            position: absolute;
            cursor: grab;
            transition: transform 0.15s ease-out; /* Suaviza rotação/inversão */
            transform-origin: center center;
            box-sizing: border-box;
            border: 1px solid rgba(0, 0, 0, 0.3);
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            touch-action: none; /* Impede o navegador de rolar/zoom ao arrastar a peça */
        }

        .tangram-piece.dragging {
            cursor: grabbing;
            z-index: 100;
            box-shadow: 0 10px 20px rgba(0,0,0,0.25);
        }
        
        /* Estilo para a peça selecionada para feedback visual */
        .tangram-piece.selected-piece {
            outline: 3px solid #007BFF;
            outline-offset: 3px;
            z-index: 101; /* Garante que a peça selecionada esteja no topo */
        }

        /* 
         CÁLCULO DAS DIMENSÕES (Baseado em L = 400px)
         A geometria do Tangram dita as dimensões para o encaixe perfeito.
        */
        .triangle-big {
            width: calc(var(--L) / 1.41421356); /* L/sqrt(2) */
            height: calc(var(--L) / 1.41421356);
            clip-path: polygon(0 0, 100% 0, 0 100%);
        }
        .triangle-medium {
            width: calc(var(--L) / 2); /* L/2 */
            height: calc(var(--L) / 2);
            clip-path: polygon(0 0, 100% 0, 0 100%);
        }
        .triangle-small {
            width: calc(var(--L) / (2 * 1.41421356)); /* L/(2*sqrt(2)) */
            height: calc(var(--L) / (2 * 1.41421356));
            clip-path: polygon(0 0, 100% 0, 0 100%);
        }
        .square {
            width: calc(var(--L) / (2 * 1.41421356)); /* L/(2*sqrt(2)) */
            height: calc(var(--L) / (2 * 1.41421356));
        }
        
        .parallelogram {
            width: calc(var(--L) / 2); 
            height: calc(var(--L) / 4);
            clip-path: polygon(25% 0%, 100% 0%, 75% 100%, 0% 100%);
        }

        /* Cores das Peças */
        #tb1 { background-color: #FFC107; } /* Amarelo (Big Triangle 1) */
        #tb2 { background-color: #03A9F4; } /* Azul Claro (Big Triangle 2) */
        #tm1 { background-color: #F44336; } /* Vermelho (Medium Triangle 1) */
        #ts1 { background-color: #9C27B0; } /* Roxo (Small Triangle 1) */
        #ts2 { background-color: #FF5722; } /* Laranja Escuro (Small Triangle 2) */
        #sq1 { background-color: #4CAF50; } /* Verde (Square 1) */
        #pr1 { background-color: #E91E63; } /* Rosa (Parallelogram 1) */

        /* --- RESPONSIVIDADE --- */
        @media (max-width: 768px) {
            :root {
                --L: 300px; /* Reduz o tamanho do jogo para telas menores */
            }
            body {
                padding: 10px;
                font-size: 0.9em;
            }
            h1 { font-size: 1.8em; }
            h2 { font-size: 1.3em; }

            #game-area {
                flex-direction: column; /* Empilha os elementos verticalmente */
                gap: 20px;
            }

            #pieces-palette {
                width: 100%; /* Largura total */
                height: auto; /* Altura automática */
                min-height: 150px; /* Altura mínima para a paleta */
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); /* Grid 2x4 adaptável */
                gap: 10px;
                padding: 15px;
                box-sizing: border-box;
            }
            #pieces-palette h2 {
                grid-column: 1 / -1; /* Título ocupa todas as colunas */
            }
            /* Ajusta as peças na paleta para o layout de grid */
            #pieces-palette .tangram-piece {
                position: relative; /* Muda para relativo para fluir no grid */
                top: auto !important; /* Sobrescreve estilos inline */
                left: auto !important; /* Sobrescreve estilos inline */
                margin: auto; /* Centraliza as peças nas células do grid */
                transform: none !important; /* Reseta a transformação para exibição na paleta */
                border: 1px solid rgba(0, 0, 0, 0.3); /* Garante que a borda seja visível */
            }
            /* Ajustes de tamanho específicos para peças na paleta para caber no grid */
            #pieces-palette .triangle-big { width: calc(var(--L) / 1.41421356 * 0.7); height: calc(var(--L) / 1.41421356 * 0.7); }
            #pieces-palette .triangle-medium { width: calc(var(--L) / 2 * 0.7); height: calc(var(--L) / 2 * 0.7); }
            #pieces-palette .triangle-small { width: calc(var(--L) / (2 * 1.41421356) * 0.7); height: calc(var(--L) / (2 * 1.41421356) * 0.7); }
            #pieces-palette .square { width: calc(var(--L) / (2 * 1.41421356) * 0.7); height: calc(var(--L) / (2 * 1.41421356) * 0.7); }
            #pieces-palette .parallelogram { width: calc(var(--L) / 2 * 0.7); height: calc(var(--L) / 4 * 0.7); }


            #game-container {
                width: calc(var(--L) + 20px); /* Ajusta para L menor */
                height: calc(var(--L) + 20px);
                margin: 0 auto; /* Centraliza o container do jogo */
            }
            #gabarito {
                top: 10px;
                left: 10px;
            }

            .controls {
                width: 100%;
                padding: 15px;
                box-sizing: border-box;
            }
            .controls ul {
                max-width: none;
                text-align: center;
            }
            .controls li {
                display: inline-block;
                margin: 0 10px 8px;
            }
            .controls button {
                width: calc(50% - 10px);
                padding: 10px 15px;
                font-size: 0.9em;
            }

            #mobile-controls {
                bottom: 10px;
                right: 10px;
                gap: 8px;
            }
            #mobile-controls button {
                width: 60px; /* Botões menores para telas muito pequenas */
                height: 60px;
                font-size: 1.5em;
            }
        }

        @media (max-width: 480px) {
            :root {
                --L: 250px; /* Tamanho do jogo ainda menor */
            }
            h1 { font-size: 1.5em; }
            h2 { font-size: 1.1em; }
            #mobile-controls {
                bottom: 5px;
                right: 5px;
                gap: 5px;
            }
            #mobile-controls button {
                width: 50px;
                height: 50px;
                font-size: 1.2em;
            }
        }
    </style>
</head>
<body>

    <h1>Tangram Interativo</h1>

    <div id="game-area">
        <div id="pieces-palette" class="container">
            <h2>Peças</h2>
            <!-- Peças são adicionadas aqui via JavaScript -->
        </div>

        <div id="game-container" class="container">
            <h2>Monte o Quadrado Aqui</h2>
            <div id="gabarito"></div>
            <div id="win-message">Parabéns!<br>Você conseguiu!</div>
            <!-- Peças arrastadas vêm para cá -->
        </div>
        
        <div class="controls container">
            <h2>Controles (Desktop)</h2>
            <ul>
                <li><strong>Arrastar:</strong> Botão esquerdo do mouse.</li>
                <li><strong>Girar 45°:</strong> Tecla 'R' (na peça selecionada).</li>
                <li><strong>Inverter:</strong> Tecla 'F' (no paralelogramo selecionado).</li>
            </ul>
            <button id="check-button">Verificar Encaixe</button>
            <button id="reset-button">Reiniciar Jogo</button>
        </div>
    </div>

    <!-- Controles Mobile (Botões R e F) -->
    <div id="mobile-controls">
        <button id="rotate-button" onclick="rotateSelectedPiece()">R</button>
        <button id="flip-button" onclick="flipSelectedPiece()">F</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const gameContainer = document.getElementById('game-container');
            const piecesPalette = document.getElementById('pieces-palette');
            const resetButton = document.getElementById('reset-button');
            const checkButton = document.getElementById('check-button');
            const winMessage = document.getElementById('win-message');
            const mobileControls = document.getElementById('mobile-controls');
            const rotateButton = document.getElementById('rotate-button');
            const flipButton = document.getElementById('flip-button');

            // Obtém o valor de --L do CSS, que pode mudar com media queries
            const getLValue = () => parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--L'));
            let L = getLValue();
            let L_2 = L / 2;
            let L_4 = L / 4;
            const SQRT2 = Math.SQRT2; // 1.41421356...
            
            // --- CONFIGURAÇÃO DA SOLUÇÃO DO JOGO ---
            // As coordenadas (x, y) são o canto superior esquerdo da caixa delimitadora
            // da peça *antes* de qualquer transformação, em relação ao canto do GABARITO (0,0).
            const piecesConfig = {
                'tb1': { class: 'triangle-big', initial: { top: '50px', left: '0px' }, solution: { x: 0, y: L_2, r: 90, f: false } },
                'tb2': { class: 'triangle-big', initial: { top: '50px', left: '50px' }, solution: { x: 0, y: 0, r: 0, f: false } },
                'tm1': { class: 'triangle-medium', initial: { top: '200px', left: '40px' }, solution: { x: L_2, y: 0, r: 270, f: false } },
                'ts1': { class: 'triangle-small', initial: { top: '350px', left: '10px' }, solution: { x: L_2 + L_4, y: L_2 + L_4, r: 180, f: false } },
                'ts2': { class: 'triangle-small', initial: { top: '350px', left: '130px' }, solution: { x: L_2, y: L_2, r: 270, f: false } },
                'sq1': { class: 'square', initial: { top: '220px', left: '130px' }, solution: { x: L_2 - L/(2*SQRT2)/2, y: L_2 - L/(2*SQRT2)/2, r: 45, f: false } },
                'pr1': { class: 'parallelogram', initial: { top: '150px', left: '0px' }, solution: { x: L_4, y: L_2, r: 90, f: true } }
            };
            
            let selectedPiece = null;
            let isDragging = false;
            let offsetX, offsetY; // Deslocamento do ponteiro para o canto superior esquerdo da peça
            const pieceStates = new Map(); // Armazena { rotation, flipped, parent } para cada peça

            // Atualiza L e seus derivados quando a janela é redimensionada
            window.addEventListener('resize', () => {
                L = getLValue();
                L_2 = L / 2;
                L_4 = L / 4;
                // Re-calcula as posições de solução se necessário, ou apenas usa os valores atualizados para verificação
                // Para este jogo, as soluções são relativas a L, então os valores de solution.x/y não precisam ser re-calculados,
                // mas a verificação de vitória usará os novos L_2, L_4 etc.
            });

            // --- FUNÇÕES PRINCIPAIS DO JOGO ---

            function initializeGame() {
                piecesPalette.innerHTML = '<h2>Peças</h2>';
                gameContainer.querySelectorAll('.tangram-piece').forEach(p => p.remove());
                winMessage.style.display = 'none';

                if(selectedPiece) {
                    selectedPiece.classList.remove('selected-piece');
                }
                selectedPiece = null;
                isDragging = false;
                pieceStates.clear(); // Limpa estados anteriores

                for (const id in piecesConfig) {
                    const config = piecesConfig[id];
                    const piece = document.createElement('div');
                    piece.id = id;
                    piece.className = `tangram-piece ${config.class}`;
                    
                    // Aplica a posição inicial para a paleta
                    piece.style.top = config.initial.top;
                    piece.style.left = config.initial.left;
                    
                    pieceStates.set(piece, { rotation: 0, flipped: false, parent: 'palette' });
                    applyTransform(piece); // Aplica a transformação inicial (sem rotação/inversão)

                    piecesPalette.appendChild(piece);
                    piece.addEventListener('pointerdown', onPiecePointerDown);
                }
                updateButtonStates(); // Atualiza o estado dos botões R/F
            }

            function applyTransform(piece) {
                const state = pieceStates.get(piece);
                let transform = `rotate(${state.rotation}deg)`;
                if (state.flipped) {
                    transform += ' scaleX(-1)';
                }
                piece.style.transform = transform;
            }

            // --- LÓGICA DE SELEÇÃO, ARRASTO E SOLTURA (POINTER EVENTS) ---

            function onPiecePointerDown(e) {
                e.preventDefault(); // Previne ações padrão do navegador (seleção de texto, rolagem)

                const currentPiece = e.target.closest('.tangram-piece');
                if (!currentPiece) return;

                // Desseleciona a peça anterior se uma diferente for clicada
                if (selectedPiece && selectedPiece !== currentPiece) {
                    selectedPiece.classList.remove('selected-piece');
                }
                
                selectedPiece = currentPiece;
                selectedPiece.classList.add('selected-piece');
                updateButtonStates(); // Atualiza os botões R/F

                isDragging = true;
                selectedPiece.classList.add('dragging');
                
                // Se a peça estiver na paleta, move-a para o container do jogo
                const pieceState = pieceStates.get(selectedPiece);
                if (pieceState.parent === 'palette') {
                    const paletteRect = piecesPalette.getBoundingClientRect();
                    const gameRect = gameContainer.getBoundingClientRect();
                    
                    // Calcula a posição atual da peça em relação ao documento
                    const pieceDocLeft = paletteRect.left + currentLeftInPalette;
                    const pieceDocTop = paletteRect.top + currentTopInPalette;

                    // Define a posição da peça em relação ao gameContainer
                    selectedPiece.style.left = `${pieceDocLeft - gameRect.left}px`;
                    selectedPiece.style.top = `${pieceDocTop - gameRect.top}px`;
                    
                    gameContainer.appendChild(selectedPiece);
                    pieceState.parent = 'game';
                }

                // Calcula o offset para o arrasto
                const rect = selectedPiece.getBoundingClientRect();
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;

                document.addEventListener('pointermove', onDocumentPointerMove);
                document.addEventListener('pointerup', onDocumentPointerUp);
            }

            function onDocumentPointerMove(e) {

                const gameRect = gameContainer.getBoundingClientRect();
                let newLeft = e.clientX - gameRect.left - offsetX;
                let newTop = e.clientY - gameRect.top - offsetY;

                selectedPiece.style.left = `${newLeft}px`;
                selectedPiece.style.top = `${newTop}px`;
            }

            function onDocumentPointerUp() {
                if (!isDragging) return;

                isDragging = false;
                if (selectedPiece) {
                    selectedPiece.classList.remove('dragging');
                }
                document.removeEventListener('pointermove', onDocumentPointerMove);
                document.removeEventListener('pointerup', onDocumentPointerUp);
            }

            // Desseleciona a peça se clicar/tocar fora dela ou dos botões de controle
            document.addEventListener('pointerdown', (e) => {
                const clickedPiece = e.target.closest('.tangram-piece');

                if (selectedPiece && !clickedPiece && !clickedControl) {
                    selectedPiece.classList.remove('selected-piece');
                    selectedPiece = null;
                    updateButtonStates();
                }
            });

            // --- FUNÇÕES PARA BOTÕES R E F ---
            window.rotateSelectedPiece = function() {
                if (!selectedPiece) return;
                const state = pieceStates.get(selectedPiece);
                state.rotation = (state.rotation + 45) % 360;
                applyTransform(selectedPiece);
            };

            window.flipSelectedPiece = function() {
                const state = pieceStates.get(selectedPiece);
                state.flipped = !state.flipped;
                applyTransform(selectedPiece);
            };

            function updateButtonStates() {
                if (selectedPiece) {
                    mobileControls.classList.add('active');
                    rotateButton.disabled = false;
                    if (selectedPiece.id === 'pr1') {
                        flipButton.disabled = false;
                    } else {
                        flipButton.disabled = true;
                    }
                } else {
                    mobileControls.classList.remove('active');
                    rotateButton.disabled = true;
                    flipButton.disabled = true;
                }
            }

            // --- LÓGICA DE ROTAÇÃO E INVERSÃO PELO TECLADO (DESKTOP) ---
            document.addEventListener('keydown', (e) => {
                if (!selectedPiece) return;

                const state = pieceStates.get(selectedPiece);

                    e.preventDefault();
                    state.rotation = (state.rotation + 45) % 360;
                    applyTransform(selectedPiece);
                } 
                    e.preventDefault();
                    state.flipped = !state.flipped;
                    applyTransform(selectedPiece);
                }
            });

            // --- FUNÇÃO DE VERIFICAÇÃO DE VITÓRIA ---
            function checkWinCondition() {
                const tolerancePos = 15; // Tolerância em pixels para a posição do centro
                const toleranceRot = 10; // Tolerância em graus para a rotação
                
                const piecesInGameArea = Array.from(gameContainer.querySelectorAll('.tangram-piece'));
                if (piecesInGameArea.length !== 7) {
                     alert('Por favor, mova todas as 7 peças para a área de montagem antes de verificar.');
                     return;
                }

                let allCorrect = true;
                const gabaritoRect = document.getElementById('gabarito').getBoundingClientRect();
                const gameRect = gameContainer.getBoundingClientRect();
                
                // Calcula a posição do gabarito em relação ao canto superior esquerdo (0,0) do gameContainer
                const gabaritoOffsetX = gabaritoRect.left - gameRect.left;
                const gabaritoOffsetY = gabaritoRect.top - gameRect.top;

                for (const piece of piecesInGameArea) {
                    const state = pieceStates.get(piece);
                    const solution = piecesConfig[piece.id].solution;
                    
                    // Obtém a posição atual da peça em relação ao gameContainer

                    // Calcula o centro da peça atual em relação ao gameContainer
                    const currentPieceCenterX = currentPieceLeft + piece.offsetWidth / 2;
                    const currentPieceCenterY = currentPieceTop + piece.offsetHeight / 2;

                    // Ajusta o centro atual para ser relativo ao canto superior esquerdo (0,0) do gabarito
                    const currentCenterX_RelativeToGabarito = currentPieceCenterX - gabaritoOffsetX;
                    const currentCenterY_RelativeToGabarito = currentPieceCenterY - gabaritoOffsetY;

                    // Calcula o centro esperado da peça em relação ao canto superior esquerdo (0,0) do gabarito
                    // solution.x/y já estão definidos em relação ao canto superior esquerdo do gabarito
                    const solutionCenterX = solution.x + piece.offsetWidth / 2;
                    const solutionCenterY = solution.y + piece.offsetHeight / 2;

                    // 3. Compara os centros (posição)
                    const posCorrect = Math.abs(currentCenterX_RelativeToGabarito - solutionCenterX) < tolerancePos && 
                                       Math.abs(currentCenterY_RelativeToGabarito - solutionCenterY) < tolerancePos;
                    
                    // 4. Compara a rotação
                    const normalizedCurrentRot = (state.rotation % 360 + 360) % 360;
                    const normalizedSolutionRot = (solution.r % 360 + 360) % 360;
                    const rotDiff = Math.abs(normalizedCurrentRot - normalizedSolutionRot);

                    // 5. Compara o estado de inversão
                    const flipCorrect = state.flipped === solution.f;

                    // Se qualquer verificação falhar, a peça está incorreta.
                        allCorrect = false;
                        console.log(`--- Peça ${piece.id} Incorreta ---`);
                        console.log(`Centro Esperado (rel. gabarito): (${solutionCenterX.toFixed(1)}, ${solutionCenterY.toFixed(1)})`);
                        console.log(`Centro Atual (rel. gabarito): (${currentCenterX_RelativeToGabarito.toFixed(1)}, ${currentCenterY_RelativeToGabarito.toFixed(1)}) -> Pos OK: ${posCorrect}`);
                        console.log(`Rotação Esperada: ${solution.r}°, Atual: ${state.rotation}° -> Rot OK: ${rotCorrect}`);
                        console.log(`Inversão Esperada: ${solution.f}, Atual: ${state.flipped} -> Flip OK: ${flipCorrect}`);
                        // Não usamos 'break' para que todas as peças incorretas sejam logadas no console, ajudando a depurar.
                    }
                }

                if (allCorrect) {
                    winMessage.style.display = 'block';
                } else {
                    alert('Ainda não está correto. Continue tentando! (Verifique o console do navegador para dicas detalhadas)');
                }
            }

            // --- INICIALIZAÇÃO E LISTENERS GERAIS ---
            resetButton.addEventListener('click', initializeGame);
            checkButton.addEventListener('click', checkWinCondition);
            
            initializeGame();
        });
    </script>
</body>
</html>
